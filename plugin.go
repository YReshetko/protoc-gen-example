package main

import (
	"bytes"
	"fmt"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"log"
	"protoc-gen-example/proto"
	"strings"
)

var imps = []string{
	"proto \"github.com/golang/protobuf/proto\"",
}

type b struct {
	bytes.Buffer
	prefix string
}

func processRequest(rq *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {
	rs := new(plugin.CodeGeneratorResponse)
	log.Println("Files to generate: ", rq.FileToGenerate)
	for _, protoFile := range rq.ProtoFile {
		if !contains(rq.FileToGenerate, *protoFile.Name) {
			continue
		}
		buff := new(b)
		buff.header(*protoFile.Package)

		for _, serv := range protoFile.GetService() {
			serviceName := serv.Name
			log.Println("Working with service: ", serviceName)
			for _, method := range serv.Method {
				methodName := method.Name
				log.Println("Working with method: ", methodName)
				roles := extractRoles(method.Options)
				log.Println("Get roles option:", roles)
			}
		}

		rs.File = append(rs.File, &plugin.CodeGeneratorResponse_File{
			Name:    proto.String(generatedFileName(protoFile)),
			Content: proto.String(buff.String()),
		})

	}
	log.Println(rs.File)
	return rs
}

func contains(arr []string, str string) bool {
	for _, val := range arr {
		if val == str {
			return true
		}
	}
	return false
}

func extractRoles(options *descriptor.MethodOptions) string {
	log.Printf("Option %+v\n", options)
	roles, err := proto.GetExtension(options, test_example.E_Roles)
	if err != nil {
		panic(err)
	}
	if roles == nil {
		return ""
	}
	var out string
	switch t := roles.(type) {
	case string:
		out = t
	case *string:
		out = *t
	default:
		panic("roles have unknown type")
	}
	return out
}

func (buff *b) header(pack string) {
	buff.write("// Code generated by protoc-gen-example. DO NOT EDIT.")
	buff.write('\n')
	buff.write(fmt.Sprintf("package %s", strings.Replace(pack, ".", "_", -1)))
	buff.write('\n')
	buff.imports()
	buff.write('\n')
	buff.write("const _ = proto.ProtoPackageIsVersion3")
	buff.write('\n')
}

func (buff *b) imports() {
	buff.write("import (")
	buff.write('\n')
	buff.tab()
	for _, imp := range imps {
		buff.write(imp)
		buff.write('\n')
	}
	buff.shiftab()
	buff.write(')')
	buff.write('\n')
}

func (buff *b) tab() {
	buff.prefix = buff.prefix + "\t"
}
func (buff *b) shiftab() {
	buff.prefix = buff.prefix[1:]
}

func (buff *b) write(value ...interface{}) {
	buff.WriteString(buff.prefix)
	for _, v := range value {
		switch t := v.(type) {
		case string:
			buff.WriteString(t)
		case *string:
			buff.WriteString(*t)
		case byte:
			buff.WriteByte(t)
		case rune:
			buff.WriteRune(t)
		default:
			panic(fmt.Sprintf("Unknown type: %+v", t))
		}
	}
}

func generatedFileName(protoFile *descriptor.FileDescriptorProto) string {
	fileName := protoFile.GetName()
	if strings.HasSuffix(fileName, ".proto") {
		fileName = fileName[:len(fileName)-len(".proto")]
	}
	outputFile := fileName + ".ex" + ".go"

	return outputFile
}
